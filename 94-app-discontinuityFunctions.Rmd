`r if(knitr:::is_latex_output()) '\\appendix'`

`r if(!knitr:::is_latex_output()) '# (APPENDIX) Appendix {-appDiscont}'`

# Appendix D: Functions used to calculate discontinuities in avian body mass distributions. {-#appDiscont}

## About
This code was first published in @barichievy2018method and has been slightly modified and annotated for the purposes of this dissertation. This code was used to produce body mass discontinuities in Chapter \#ref(discontinuity)

## Neutral.Null function
Neutral.Null <- function(log10.data, resolution = 4000) {
  Dmax = max(log10.data, na.rm = FALSE)
  Dmin = min(log10.data, na.rm = FALSE)
  ds = (Dmax - Dmin) / resolution
  MaxK = (Dmax - Dmin) / 2
  MinK = ds * 2
  
  #define h's to analyze
  ks = seq(MinK, MaxK, by = 1 / resolution)
  
  # generate matrix
  bws = matrix(data = NA,
               nrow = length(ks),
               ncol = 1)
  
  for (i in c(1:length(ks))) {
    # Calculate KS density estimate
    KSdens <- density(log10.data, bw = ks[i], "gaussian", adjust = 1)
    
    # Test if the ksdensity is unimodal
    TF <- which(diff(sign(diff(KSdens$y))) == 2) + 1
    if (length(TF) == 0)
      bws[i] = 1
    else
      bws[i] = 0
  }
  # Define the neutral Null
  r = min(which(bws == 1))
  hnull = ks[r]
  return(hnull)
}

## Bootstrapping Function
DD <- function(log10.data, hnull, Sample.N = 1000) {
  NNull <- density(log10.data, bw = hnull, "gaussian", adjust = 1)
  N <- length(log10.data)
  
  # generate matrix
  null.samples <- matrix(data = 0,
                         ncol = Sample.N,
                         nrow = N)
  for (i in 1:Sample.N) {
    #sample the null model
    rand.N <- sample(NNull$x, N, replace = TRUE, prob = NNull$y)
    #calculate the gaps
    null.samples[, i] <- sort(rand.N, decreasing = FALSE)
    #put into the matrxi
  }
  
  # generate gaps
  gaps.log10.data <- diff(log10.data)
  gaps.null.samples <- diff(null.samples, decreasing = FALSE) # difference between random samples and 1st diff orig dat
  gap.percentile <- matrix(data = 0,
                           nrow = length(gaps.log10.data),
                           ncol = 1)
  for (i in 1:length(gaps.log10.data)) {
    # generate distribution of gaps per row (per gap rank)
    gap.percentile[i] <-
      ecdf(gaps.null.samples[i, ])(gaps.log10.data[i]) # returns the percentile at each observation
    
  }
  Bootstrap.gaps <- rbind(gap.percentile, 0)
  Bootstrap.gaps <- cbind(log10.data, Bootstrap.gaps)
  return(Bootstrap.gaps)
}


